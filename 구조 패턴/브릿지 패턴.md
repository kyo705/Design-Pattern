# Bridge 패턴

브릿지 패턴은 기능과 구현을 분리하는 패턴이다. 추상 클래스에서는 추상 메소드와 구현된 메소드가 존재한다. 그 때, 추상 메소드는 해당 클래스를 상속받은 구현 클래스를 통해 구체화하여 확장하고, 추상 클래스의 추상 메소드가 아닌 다른 메소드들(기능)은 기능 클래스를 통해 사용한다. 이 때, 기능 클래스는 인터페이스로 선언 후 상황에 맞게 바꿔 끼우도록([전략 패턴 사용](https://github.com/kyo705/Design-Pattern/blob/master/%ED%96%89%EC%9C%84%20%ED%8C%A8%ED%84%B4/%EC%A0%84%EB%9E%B5%20%ED%8C%A8%ED%84%B4.md#strategy-%ED%8C%A8%ED%84%B4))한다.   

![image](https://user-images.githubusercontent.com/89891704/161424862-99d3b833-cb6e-484b-91e6-02c311e653f4.png)   

```JAVA
public abstract class AbstarctClazz{
	//해당 클래스의 기능을 사용하기 위한 기능클래스 인스턴스 생성
	private ConcreteFunc concretefunc = new  ConcreteFuncImpl();
	
	//추상 메소드 => 상속을 통해 구현 가능
	public abstract void abstractfunc();
	
	//기능 1
	public void concretefunc1() {
		concretefunc.func1();
	}
	//기능 2
	public void concretefunc2() {
		concretefunc.func2();
	}
}

//추상 클래스를 상속받은 구현 클래스
public class ConcreteClazz extends AbstarctClazz {

	@Override
	public void abstractfunc() {
		System.out.println("구현 로직");
	}
	 
 }
```
```java
 //추상 클래스의 기능을 담당하는 인터페이스
 public interface ConcreteFunc{
	 public void func1();
	 public void func2();
 }
 //추상 클래스의 기능을 구체화한 클래스
 public class ConcreteFuncImpl implements ConcreteFunc {

	@Override
	public void func1() {
		System.out.println("기능 1");
	}

	@Override
	public void func2() {
		System.out.println("기능 2");
	}
	 
 }
```
## 브릿지 패턴의 필요성   
해당 패턴을 필요로하는 경우는 기능 부분과 구현 부분이 독립적으로 작용할 때 사용하면 좋다. 기능 부분이 구현 부분에 종속되면 그냥 추상 클래스를 상속받아 구현 클래스를 만드는 방식과 똑같다. 하지만 기능 부분과 구현 부분이 독립적이라면 기능이 N개 필요하고 구현이 M개 필요한 경우 브릿지 패턴으로 N x M 개를 만들 수 있다.

## [목록 돌아가기](https://github.com/kyo705/Design-Pattern/blob/master/README.md#1-%EC%83%9D%EC%84%B1-%ED%8C%A8%ED%84%B4)
